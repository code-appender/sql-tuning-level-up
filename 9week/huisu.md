# SQL 옵티마이저

## 통계 정보와 비용 계산 원리

### 선택도와 카디널리티

- 선택도는 전체 레코드 중에서 조건절에 의해 선택되는 레코드 비율
- 가장 단순한 조건으로 검색할 때의 선택도만 살펴보면 컬럼 값 종류 개수를 이용해 구함
- 카디널리티는 전체 레코드 중 조건절에 의해 선택되는 레코드 개수

### 통계 정보

- 오브젝트 통계
    - 테이블 통계

    - 컬럼 통계

        - 컬럼 히스토그램
            - ‘=’ 조건에 대한 선택도는 1/NUM_DISTINCT 공식으로 구하거나 미리 구해 놓은 DENSITY 값을 이용
            - 일반적인 컬럼에는 이 공식이 비교적 잘 들어맞지만, 데이터 분포가 균일하지 않은 컬럼에는 그렇지 못함
            - 선택도를 잘못 구하면 데이터 액세스 비용을 잘못 산정하게 되고, 결국 최적이 아닌 실행계획으로 이어짐
            - 그래서 옵티마이저는 일반적인 컬럼 통계 외에 히스토그램을 추가로 활용
- 시스템 통계
    - 시스템 통계는 애플리케이션 및 하드웨어 성능 특성을 측정한 것이며, 아래 항목들을 포함
    - CPU 속도
    - 평균적인 Single Block I/O 속도
    - 평균적인 Multiblock I/O 속도
    - 평균적인 Multiblock I/O 개수
    - I/O 서브시스템의 최대 처리량(Throughput)
    - 병렬 Slave의 평균적인 처리량(Throughput)

### 비용 계산 원리

- 단일 테이블을 인덱스로 액세스할 때 비용 계산 방법
- 인덱스 키값을 모두 ‘=’ 조건으로 검색할 때, 인덱스 통계만으로도 쉽게 비용을 계산 가능
- 인덱스 키값이 모두 ‘=’ 조건이 아닐 때는 컬럼 통계까지 활용
- BLEVEL, LEAF_BLOCKS, CLUSTERING_FACTOR는 인덱스 통계에서 얻을 수 있고, 유효 인덱스 선택도와 유효 테이블 선택도는 컬럼 통계 및 히스토그램을 이용해 계산
- 유효 인덱스 선택도: 전체 인덱스 레코드 중, 액세스 조건에 의해 선택될 것으로 예상되는 레코드 비중을 의미
- 유효 테이블 선택도: 전체 인덱스 레코드 중 인덱스 컬럼에 대한 모든 조건절에 의해 선택될 것으로 예상되는 레코드 비중

## 옵티마이저에 대한 이해

### 옵티마이저 종류

- 비용기반(Cost-Based) 옵티마이저 (CBO)
    - 사용자 쿼리를 위해 후보군이 될만한 실행계획을 도출
    - 데이터 딕셔너리(Data Dictionary)에 미리 수집해 둔 통계정보를 이용해 각 실행계획의 예상비용을 산정
    - 그중 가장 낮은 비용의 실행계획 하나를 선택하는 옵티마이저
    - CBO가 사용하는 통계정보로는데이터량,컬럼 값의 수,컬럼 값 분포,인덱스 높이,클러스터링 팩터
- 규칙기반(Rule-Based) 옵티마이저 (RBO)
    - 각 액세스 경로에 대한 우선순위 규칙에 따라 실행계획을 만드는 과거의 옵티마이저
    - 데이터 특성을 나타내는 통계정보를 전혀 활용하지 않고 단순한 규칙에만 의존하기 때문에 대량 데이터를 처리하는 데 부적합

### 옵티마이저 모드

- ALL_ROWS
    - 전체 처리속도 최적화
    - 옵티마이저는 쿼리 결과집합 ‘전체를 읽는 것을 전제로’ 시스템 리소스(I/O, CPU, 메모리 등)를 가장 적게 사용하는 실행계획을 선택
    - 즉, 전체 처리속도 최적화가 목표
- FIRST_ROWS
    - 최초 응답속도 최적화
    - 옵티마이저는 전체 결과집합 중 ‘앞쪽 일부만 읽다가 멈추는 것을 전제로’ 응답 속도가 가장 빠른 실행계획을 선택
    - 즉, 최초 응답속도 최적화가 목표
    - ALL_ROWS와 비교하면, Table Full Scan 보다 인덱스를 더 많이 선택하고,
      해시 조인, 소트 머지 조인보다 NL 조인을 더 많이 선택하는 경향을 보임
    - 실 이 옵티마이저 모드는 앞으로 사라지게 될(deprecated) 옵티마이저 모드이기 때문에, FIRST_ROWS_N을 사용해야 함
- FIRST_ROWS_N
    - 최초 N건 응답속도 최적화
    - 옵티마이저는 사용자가 ‘앞쪽 N개 로우만 읽고 멈추는 것을 전제로’ 응답 속도가 가장 빠른 실행계획을 선택
    - ALTER SYSTEM 또는 ALTER SESSION 명령어로 옵티마이저 모드를 설정할 때 N으로 지정할 수 있는 값은 아래와 같이 1, 10, 100, 1000 네 가지

### 옵티마이저에 영향을 미치는 요소

- SQL와 연산자 형태: 결과가 같더라도 SQL을 어떤 형태로 작성했는지 또는 어떤 연산자 (=, IN, LIKE, BETWEEN, 부등호 등)를 사용했는지에 따라 옵티마이저가 다른 선택을 할 수 있고, 궁극적으로 쿼리 성능에 영향을 미침
- 인덱스, IOT, 클러스터 등 옵티마이징 팩터: 쿼리를 똑같이 작성해도 인덱스, IOT, 클러스터, 파티션, MV 등을 구성했는지, 그리고 어떤 식으로 구성했는지에 따라 실행계획과 성능이 달라짐
- 제약 설정: DBMS에 설정한 PK, FK, CHECK, NOT NULL 같은 제약들은 데이터 무결설 보장해주고 옵티마이저가 쿼리 성능을 최적화하는데 중요한 메타정보로 활용
- 통계 정보: SQL 옵티마이저가 사용하는 통계정보에 문제가 생기면 애플리케이션 성능이 갑자기 느려지고 심할땐 장애 상황으로 이어짐
- 옵티마이저 힌트

### 옵티마이저의 한계

- 네비게이션도 실수하듯 옵티마이저도 완벽하지 않고 한계가 있음
- 옵티마이저 핸동에 가장 큰 영향을 미치는 통계정보를 ‘필요한 만큼 충분히’ 확보하는 것은 불가능한 일
- 통계정보를 완벽히 수집해도 바인드 변수를 사용한 SQL에 컬럼 히스토그램을 활용할 수 없다는 치명적인 단점도 있음
- 기본적으로 비용기반으로 작동하나, 내부적으로 여러 가정과 정해진 규칙을 이용해 기계적인 선택을 하는것도 한계