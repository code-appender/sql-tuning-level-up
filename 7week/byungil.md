# 6. DML 튜닝

# 6.1 기본 DML 튜닝

- DML 성능에 영향을 미치는 요소에 어떤 것들이 있는지부터 살펴보자.

## 6.1.1 DML 성능에 영향을 미치는 요소

- 인덱스
- 무결성 제약
- 조건절
- 서브쿼리
- Redo 로깅
- Undo 로깅
- Lock
- 커밋

### 인덱스와 DML 성능

- 테이블에 레코드를 입력하면, 인덱스에도 입력해야 한다.
    - 테이블
        - 테이블은 Freelist를 통해 입력할 블록을 할당받는다.
    - 인덱스
        - 인덱스는 정렬된 자료구조이므로 수직적 탐색을 통해 입력할 블록을 찾아야 한다.
        - 인덱스에 입력하는 과정이 더 복잡하므로 DML 성능에 미치는 영향도 더 크다.
- 테이블에서 레코드 하나를 삭제하면, 인덱스 레코드를 모두 찾아서 삭제해줘야 한다.
- UPDATE할 때는 변경된 컬럼을 참조하는 인덱스만 찾아서 변경해주면 된다.
    - 그 대신, 테이블에서 한 건 변경할 때마다 인덱스에는 두 개 오퍼레이션이 발생한다.
    - 인덱스는 정렬된 자료구조이기 때문이다.
    - ‘A’를 ‘K’로 변경하면 저장 위치도 달라지므로 삭제 후 삽입하는 방식으로 처리한다.

### 무결성 제약과 DML 성능

- 데이터베이스에 논리적으로 의미 있는 자료만 저장되게 하는 데이터 ‘무결성 규칙’
    - 개체 무결성(Entity Integrity)
    - 참조 무결성(Referential Integrity)
    - 도메인 무결성(Domain Integrity)
    - 사용자 정의 무결성(또는 업무 제약 조건)
- ‘무결성 제약’
    - PK
    - FK
    - Check
    - Not Null
- PK, FK 제약은 Check, Not Null 제약보다 성능에 더 큰 영향을 미친다.
- Check, Not Null은 정의한 제약 조건을 준수하는지만 확인하면 되지만, Pk, FK 제약은 실제 데이터를 조회해 봐야 하기 때문이다.

### 조건절과 DML 성능

- SELECT 문과 실행계획이 다르지 않으므로 인덱스 튜닝 원리를 그대로 적용할 수 있다.

### 서브쿼리와 DML 성능

- 조인 튜닝 원리를 그대로 적용할 수 있다. (서브쿼리 조인과 밀접한 관련이 있다.)

### Redo 로깅과 DML 성능

- 오라클은 데이터파일과 컨트롤 파일에 가해지는 모든 변경사항을 Redo 로그에 기록한다.
- Redo 로그는 트랜잭션 데이터가 어떤 이유에서건 유실됐을 때, 트랜잭션을 재현함으로써 유실 이전 상태로 복구하는데 사용한다.
- DML 수행할 때마다 Redo 로그를 생성해야 하므로 Redo 로깅은 DML 성능에 영향을 미친다.
    - INSERT 작업에 대해 Redo 로깅 생략 기능을 제공하는 이유가 6.2.2에서 설명한다.
- Redo 로그의 용도 p.400

### Undo 로깅과 DML 성능

- Redo
    - Redo는 트랜잭션을 재현함으로써 과거를 현재 상태로 되돌리는데 사용한다.
    - 트랜잭션을 재현하는 데 필요한 정보를 로깅한다.
- Undo
    - Undo는 트랜잭션을 롤백함으로써 현재를 과거 상태로 되돌리는데 사용한다.
    - 변경된 블록을 이전 상태로 되돌리는 데 필요한 정보를 로깅한다.
- DML을 수행할 때마다 Undo를 생성해야 하므로 Undo 로깅은 DML 성능에 영향을 미친다.
- 그렇다고 Undo를 안 남길 수는 없다.

### Lock과 DML 성능

- Lock은 DML 성능에 매우 크고 직접적인 영향을 미친다.
- 필요 이상으로 자주, 길게 사용하거나 레벨을 높일수록 DML 성능은 느려진다.
- 너무 적게, 짧게 사용하거나 필요한 레벨 이하로 낮추면 데이터 품질이 나빠진다.

### 커밋과 DML 성능

- 커밋은 DML과 별개로 실행하지만, DML을 끝내려면 커밋까지 완료해야 하므로 서로 밀접한 관련이 있다.
- DML이 Lock에 의해 블로킹(Blocking)된 경우, 커밋은 DML 성능과 직결된다.
- DML을 완료할 수 있게 Lock을 푸는 열쇠가 바로 커밋이기 때문이다.

### 커밋의 내부 메커니즘 - (1) DB 버퍼캐시

- DB에 접속한 사용자를 대신해 모든 일을 처리하는 서버 프로세스는 버퍼캐시를 통해 데이터를 읽고 쓴다.
- 버퍼캐시에서 변경된 블록을 모아 주기적으로 데이터파일에 일괄기록하는 작업은 DBWR(Database Writer) 프로세스가 맡는다.
    - 배치 처리

### (2) Redo 로그버퍼

- 버퍼캐시에 가한 변경사항을 Redo 로그에도 기록한다.
- 버퍼캐시 데이터가 유실되더라고 Redo 로그를 이용해 언제든 복구할 수 있다.
- Redo 로그도 파일이기 때문에 Append 방식으로 기록하더라도 디스크 I/O는 느리다.
- Redo 로깅 성능 문제를 해결하기 위해 오라클은 로그버퍼를 이용한다.
- Redo 로그 파일에 기록하기 전에 먼저 로그버퍼에 기록하는 방식이다.
- 로그버퍼에 기록한 내용은 나중에 LGWR(Log Writer) 프로세스가 Redo 로그 파일에 일괄(Batch) 기록한다.

### (3) 트랜잭션 데이터 저장 과정

1. DML 문을 실행하면 Redo 로그버퍼에 변경사항을 기록한다.
2. 버퍼블록에서 데이터를 변경(레도크 추가/수정/삭제)한다. 물론, 버퍼캐시에서 블록을 찾지 못하면, 데이터파일에서 읽는 작업부터 한다.
3. 커밋한다.
4. LGWR(Log Writer) 프로세스가 Redo 로그버퍼 내용을 로그파일에 일괄 저장한다.
5. DBWR(Database Writer) 프로세스가 변경된 버퍼블록들은 데이터파일에 일괄 저장한다.
- 오라클은 데이터를 변경하기 전에 항상 로그부터 기록한다.
    - 이를 ‘Write Ahead Logging’이라고 부른다.

### (4) 커밋 = 저장 버튼

- 커밋은 문서 작업 도중에 ‘저장’ 버튼을 누르는 것과 같다.
- 서버 프로세스가 그때까지 했던 작업을 디스크에 기록하라는 명령어인 셈이다.
- 저장을 완료할 때까지 서버 프로세스는 다음 작업을 진행할 수 없다.
- Redo 로그버퍼에 기록된 내용을 디스크에 기록하도록 LGWR 프로세스에 신호를 보낸 후 작업을 완료했다는 신호를 받아야 다음 작업을 진행할 수 있다. → Sync 방식이다.
- LGWR 프로세스가 Redo 로그를 기록하는 작업은 디스크 I/O 작업이다. 커밋은 그래서 생각보다 느리다.
- 트랜잭션을 필요 이상으로 길게 정의함으로써 오랫동안 커밋하지 않는 것도 문제지만, 너무 자주 커밋하는 것도 문제다.
- 오랫동안 커밋하지 않은 채 데이터를 계속 갱신하면 Undo 공간이 부족해져 시스템 장애 상황을 유발할 수 있다.
- 루프를 돌면서 건건이 커밋한다면, 프로그램 자체 성능이 매우 느려진다.
- 트랜잭션을 논리적으로 잘 정의함으로써 불필요한 커밋이 발생하지 않도록 구현해야 한다.

## 6.1.2 데이터베이스 Call과 성능

### 데이터베이스 Call

- SQL은 세 단계로 나누어 실행된다.
    - Parse Call:
        - SQL 파싱과 최적화를 수행하는 단계다. SQL과 실행계획을 라이브러리 캐시에서 찾으면, 최적화 단계는 생략할 수 있다.
    - Execute Call:
        - 말 그대로 SQL을 실행하는 단계다. DML은 이 단계에서 모든 과정이 끝나지만, SELECT 문은 Fetch 단계를 거친다.
    - Fetch Call:
        - 데이터를 읽어서 사용자에게 결과집합을 전송하는 과정으로 SELECT 문에서만 나타난다. 전송할 데이터가 많을 때는 Fetch Call이 여러 번 발생한다.
- Call이 어디서 발생하느냐에 따라 User Call과 Recursive Call로 나눌 수 있다.
    - User Call:
        - 네트워크를 경유해 DBMS 외부로부터 인입되는 Call이다.
        - 3-Tier 아키텍처에서 User Call은 WAS 서버에서 발생하는 Call이다.
    - Recursive Call:
        - DBMS 내부에서 발생하는 Call이다.
        - SQL 파싱과 최적화 과정에서 발생하는 데이터 딕셔너리 조회, PL/SQL로 작성한 사용자 정의 함수/프로시저/트리거에 내장된 SQL을 시랳ㅇ할 때 발생하는 Call이 여기 해당함.
- User Call이든 Recursive Call이든, SQL을 실행할 때마다 Parse, Execute, Fetch Call 단계를 거친다.
- 데이터베이스 Call이 많으면 성능은 느릴 수 밖에 없다.
- 특히 네트워크 경유하는 User Call이 성능에 미치는 영향은 매우 크다.

## 6.1.3 Array Processing 활용

- One SQL로 구현하지 않고도 Call 부하를 획기적으로 줄일 수 있다.
- insert를 원하는 개수만큼 모아서 한번에 실행시키는 방법이다.

## 6.1.4 인덱스 및 제약 해제를 통한 대량 DML 튜닝

- 인덱스와 무결성 제약 조건은 DML 성능에 큰 영향을 끼친다.
- 동시 트랜잭션 없이 대량 데이터를 적재하는 배치(Batch) 프로그램에서는 이들 기능을 해제함으로써 큰 성능개선 효과를 얻을 수 있다.
- PK 제약과 인덱스 해제 후 재설정을 통해 성능 개선

## 6.1.5 수정가능 조인 뷰

- 다른 테이블과 조인하여 UPDATE를 할 때, 비효율적일 수 있다.
- 수정가능 조인 뷰를 활용하여 테이블과 조인하는 비효율을 없앨 수 있다.

## 6.1.6 MERGE 문 활용

- Left Outer 조인을 수행하여 성공하면 UPDATE, 실패하면 INSERT 한다.
- MERGE 문을 UPSERT(= UPDATE + INSERT)라고도 부르는 이유다.
- DELETE절을 적용할 수 있고, 조인에 성공하였을 때만 적용할 수 있다.
- SQL을 두 번 → 한 번으로 줄일 수 있다.

---

# 6.2 Direct Path I/O 활용

- 반복적으로 읽기는 버퍼캐시가 성능 향상에 도움을 준다.
- 반면 배치 프로그램에서 사용하는 SQL은 주로 대량 데이터를 처리하기 때문에 버퍼캐시를 경유하는 I/O 메커니즘이 오히려 성능을 떨어뜨릴 수 있다.
- `오라클은 버퍼캐시를 경유하지 않고 곧바로 데이터 블록을 읽고 쓸 수 있는 Direct Path I/O 기능을 제공한다.`

## 6.2.1 Direct Path I/O

- 대량 데이터를 읽고 쓸 때 건건이 버퍼캐시를 탐색한다면 성능에는 오히려 안 좋다.
    - 버퍼캐시에서 블록을 찾을 가능성이 거의 없기 때문이다.
- 대량 블록을 건건이 디스크로부터 버퍼캐시에 적재하고서 읽어야 하는 부담도 크다.

### Direct Path I/O 작동하는 경우

- 병렬 쿼리로 Full Scan을 수행할 때
- 병렬 DML을 수행할 때
- Direct Path Insert를 수행할 때
- Temp 세그먼트 블록들을 읽고 쓸 때
- direct 옵션을 지정하고 export를 수행할 때
- nocache 옵션을 지정한 LOB 컬럼을 읽을 때

## 6.2.2 Direct Path Insert

- 일반적인 INSERT가 느린 이유는 다음과 같다.
    - 데이터를 입력할 수 있는 블록을 Freelist에서 찾는다. 테이블 HWM(High-Water-Mark) 아래쪽에 있는 블록 중 데이터 입력이 가능한(여유 공간이 있는) 블록을 목록으로 관리하는데, 이를 Freelist라고 한다.
    - Freelist에서 할당받은 블록을 버퍼캐시에서 찾는다.
    - 버퍼캐시에 없으면, 데이터파일에서 읽어 버퍼캐시에 적재한다.
    - INSERT 내용을 Undo 세그먼트에 기록한다.
    - INSERT 내용을 Redo 로그에 기록한다.
- 데이터를 `Direct Path Insert` 방식으로 입력하는 방법
    - INSERT …. SELECT 문에 append 힌트 사용
    - parallel 힌트를 이용해 병렬 모드로 INSERT
    - direct 옵션을 지정하고 SQL Loader(sqlldr)로 데이터 적재
    - CTAS(create table … as select) 문 수행
- `Direct Path Insert` 방식이 빠른 이유
    - Freelist를 참조하지 않고 HWM 바깥 영역에 데이터를 순차적으로 입력한다.
    - 블록을 버퍼캐시에서 탐색하지 않는다.
    - 버퍼캐시에 적재하지 않고, 데이터파일에 직접 기록한다.
    - Undo 로깅을 안 한다.
    - Redo 로깅을 안 하게 할 수 있다. 테이블을 nologging 모드로 전환한 상태에서 Direct Path Insert 하면 된다.
        - alter table t NOLOGGING;
    - 참고로 일반 INSERT 문을 로깅하지 않게 하는 방법은 없다.

### Direct Path Insert 주의할 점

- 성능은 비교할 수 없이 빨라지지만 Exclusive 모드 TM Lock이 걸린다는 사실이다.
    - 따라서 커밋하기 전까지 다른 트랜잭션은 해당 테이블에 DML을 수행하지 못한다.
    - 트랜잭션이 빈번한 주간에 이 옵션을 사용하는 것은 절대 금물이다.
- Freelist를 조회하지 않고 HWM 바깥 영역에 입력하므로 테이블에 여유 공간이 있어도 재활용하지 않는다는 사실이다.
    - 파티션 DROP 방식으로 지워야 공간 반환이 제대로 이루어진다.
    - 비파티션 테이블이면 주기적으로 Reorg 작업을 수행해줘야 한다.

## 6.2.3 병렬 DML

- UPDATE, DELETE는 기본적으로 Direct Path Write가 불가능하다.
- 유일한 방법은 병렬 DML로 처리하는 것이다.