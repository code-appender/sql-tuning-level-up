# 소트 튜닝

## 소트 연산에 대한 이해

### 소트 수행 과정

- 소트는 PGA에 할당한 Sort Area에서 수행하며 PGA가 부족하면 Temp 테이블 스페이스를 사용
- 메모리 소트: PGA 내에서 소트를 완료할 경우
- 디스크 소트: Temp 테이블 스페이스까지 활용하여 소트를 완료할 경우
- 소트는 최대한 발생하지 않도록 SQL을 작성해야 하고, 소트가 불가피하다면 메모리 내에서 수행할 수 있도록 작성

### 소트 오퍼레이션

**Sort Aggregate**

- 전체 로우를 대상으로 집계를 수행할 때
- MAX, MIN, SUM, AVG 함수를 사용할 때 나타남
- 실제로 데이터를 정렬하지는 않고 Sort Area를 사용하는 정도

**Sort Order By**

- 데이터를 정렬할 때 나타나는 기본적인 소트 오퍼레이션

**Sort Group By**

- 그룹별 집계에 나타나는 오퍼레이션
- 각각의 그룹별로 Sort Aggregate에서 했던 방식대로 사용
- 각각의 그룹을 대표하는 값에 대해 Order By가 없다면 Hash Group By 오퍼레이션 사용

**Sort Unique**

- 중복 레코드를 제거하는 소트 오퍼레이션
- 만약 유일성이 보장된다면 이 오퍼레이션은 생략
- Distinct 연산자에서도 사용

**Sort Join**

- 소트 머지 조인 수행할 때 사용

**Window Sort**

- 윈도우 함수를 수행할 때 나타남

## 소트가 발생하지 않도록 SQL 작성

### Union vs Union All

- Union은 중복을 제거하기 위해 소트 연산
- Union All은 중복을 제거하지 않기에 소트 연산 없음
- 중복일 수 없는 데이터들의 집합을 Union으로 처리하면 낭비이기 때문에 데이터가 중복되지 않는다면 Union All 사용
- 소트 연산이 일어나지 않도록 Union All을 사용하여 중복을 피하는 방법이 있음

### Exists 활용

- Distinct는 중복을 제거하기 위해 소트 연산을 함
- 데이터가 존재하는지만 확인할 때는 Exists 활용

## 인덱스를 이용한 소트 연산 생략

### Sort Order By 생략

- 인덱스는 항상 키 컬럼 순으로 결정된 상태를 유지하기 때문에 인덱스를 이용해서 소트 연산이 생략 가능

### Top N 쿼리

- 전체 결과 집합 중 상위 N개 레코드만 선택하는 쿼리
- 인덱스를 탄다면 부분 범위 처리로 딱 10개만 만나면 멈춤
- 실행 계획에는 COUNT(STOPKEY)라고 표현되며 이를 Top N Stopkey 알고리즘이라고 함
- 페이징 처리를 할 때 Top N 쿼리를 사용하는데 반드이 ROWNUM을 사용해야 함

### 최소값/최대값 구하기

- 조건절 컬럼 + MIN/MAX 함수 인자의 컬럼이 모두 인덱스에 포함되어 있어야지 소트를 하지 않음
- 이런 경우 First Row Stopkey 알고리즘이 사용되었다고 함

### Sort Group By 생략

- Group By에 선두 컬럼 인덱스가 있다면 인덱스를 통해 Sort Group By 연산 생략 가능
- Sout Group By Nosort라고 표현

## Sort Area를 적게 사용하도록 SQL 작성

### 소트 데이터 줄이기

- 소트 연산이 불가피하다면 메모리 내에서 처리를 완료하도록 노력
- Sort Area에 저장을 적게 해야 하기에 SELECT 절에 필요한 항목만 넣음

### Top N 쿼리의 소트 부하 경감 원리

- 실행계획에 Sort Order By와 Stopkey가 함께 나타남
- 소트 연산을 피할 수 없어 Sort Order By를 하지만 Top N 소트 알고리즘이 작동하는 것을 보여 줌
- Sort Area 사용량이 최소화되어 대상 집합이 커도 많은 메모리를 잡아 먹지 않음
- 전체 레코드를 다 정렬하지 않아도 오름차순으로 최소값을 갖는 10개의 레코드를 정확하게 찾을 수 있음

### Top N 쿼리가 아닐 때 발생하는 소트 부하

- Top N 소트 알고리즘이 작동하지 않는다면 Temp 테이블 스페이스를 이용해서 부하 발생