# 4장 조인 튜닝

## NL 조인

### @ NL 조인의 기본 매커니즘
- NL조인의 기본 매커니즘은 중첩 루프문이다.
- 일반적으로 NL 조인은 Outer와 Inner 양쪽 테이블 모두 인덱스를 이용한다.
- Outer 쪽 테이블의 사이즈가 크지 않으면 Table Full Scan을 하더라도 한 번에 끝날 수 있기 때문에 인덱스를 이용하지 않을 수 있다.
- 반면 Inner 테이블 쪽이 크지 않더라도 Outer가 크다면 인덱스를 이용해야 한다.
- 따라서 NL 조인은 인덱스를 이용한 조인 방식이라고 할 수 있다.

### @ NL 조인 실행계획 제어
- NL 조인을 제어하기 위해서는 `use_nl` 힌트를 사용해야 한다.
```sql
SELECT /*+ ordered use_nl(a) use_nl(b) use_nl(c) use_hash(d)*/ *
FROM a, b, c, d
WHERE a.id = b.id
AND b.id = c.id
AND c.id = d.id;
```
- ordered 힌트는 FROM 절에 기술한 순ㅇ서대로 조인하라고 옵티마이저에게 지시한다.
- 위의 예시는 a -> b -> c -> d 순으로 조인하고 B와 C에 대해서는 NL조인, D와 조인할 떄는 해시 조인을 사용하라는 힌트이다.

```sql
SELECT /*+ leading(c,a,d,b) use_nl(a) use_nl(b) use_nl(c) use_hash(d) */ *
FROM a, b, c, d
WHERE a.id = b.id
AND b.id = c.id
```
- leading 힌트는 FROM 절을 바꾸지 않고 순서를 제어할 수 있다.

### @ NL 조인의 특징
- 랜덤 액세스 위주의 조인 방식
- 조인을 한 레코드씩 순차적으로 진행
- 인덱스 구성 전략이 중요

### @ NL 조인 확장 매커니즘
오라클은 버전이 올라가면서 NL 조인 성능을 높이기 위해서 테이블 Prefetch, 배치 I/O 기능을 도입했다.
- 테이블 Prefetch: 인덱스를 이용해 테이블을 액세스하다가 디스크 I/O가 필요해지면 이어서 곧 읽게 될 블록까지 미리 읽어들여 버퍼캐시에 저장하는 기능
    ```sql
    TABLE ACCESS BY INDEX ROWID OF 고객
    NESTED LOOPS
    ,,,
    ```
  - 위의 쿼리처럼 Index Scan 부분과 Nest Loops가 뒤바뀐 실행계획은 Prefetch가 적용된 것이다. 이는 Inner 쪽 테이블에 대한 디스크I/O 과정에 테이블 Prefetch 기능이 작동할 수 있음을 표시하기 위함이다.
- 배치 I/O: 디스크 I/O Call을 미뤄뒀다가 읽을 블록이 일정량 쌓이면 한꺼번에 처리하는 기능.
- ```sql
  NESTED LOOPS
    NESTED LOOPS
      TABLE ACCESS BY INDEX ROWID OF 고객
          INDEX RANGE SCAN OF 고객_PK
      INDEX RANGE SCAN OF 주문_FK
    TABLE ACCESS BY INDEX ROWID OF 주문        
  ``` 
- Innere 쪽 테이블에 대한 디스크 I/O 과정에서 배치 I/O 기능이 작동할 수 있음을 표시하기 위함이다.

두 기능 모두 읽는 블록마다 건건히 I/O Call을 발생시키는 비효율을 줄이기 위해 고안되었다.

오라클 11g에서는 위 세 가지 실행계획이 모두 나타나는데 Inner 쪽 테이블 블록을 모두 버퍼캐시에서 읽는다면 어떤 방식으로 수행하든 성능에 차이가 없다.<br>
하지만 일부를 디스크에서 읽게 되면 성능에 차이가 나타날 수 있고 배치 I/O 실행계획이 나타날 때는 결과집합의 정렬 순서도 다를 수 있다.

## 4.2 소트 머지 조인
조인 컬럼에 인덱스가 없을 떄, 대량 데이터 조인이어서 인덱스가 효과적이지 않을 때, 옵티마이저는 NL 조인 대신 소트 머지 조인이나 다음 절에서 설명할 해시 조인을 선택한다.<br>

### @ SGA vs PGA
- SGA(System Global Area): 오라클 인스턴스가 시작될 때 할당되는 메모리 영역으로, 데이터베이스 인스턴스 전체에서 공유되는 메모리 영역이다.
- PGA(Program Global Area): 오라클 인스턴스가 시작될 때 할당되는 메모리 영역으로, 각 세션별로 할당되는 메모리 영역이다.

오라클 서버 으포레스는 SGA에 공유된 데이터를 읽고 쓰면서, 동시에 자신만의 고유 메모리 영역을 갖는다. <br>
각 오라클 서버 프로세스에 할당된 메모리 영역을 PGA라고 하며 프로세스에 종속적인 고유 데이터를 저장하는 용도로 사용한다. <br>
할당받은 PGA 공간이 작아 데이터를 모두 저장할 수 없을 때는 Temp 테이블스페이스를 이용한다.

PGA는 다른 프로세스와 공유하지 않는 독립적인 메모리 공간이므로 래치 매커니즘이 불필요하다. 따라서 같은 양의 데이터를 읽더라도 SGA 버퍼캐시에서 읽을 때보다 훨씬 빠르다.

### @ 소트 머지 조인의 기본 매커니즘
소트 머지 조인은 두 테이블을 각각 소트한 후에 두 테이블을 병합하는 방식이다. <br>
```sql
-- use_merge : 소트 머지 조인을 사용하라는 의미이다.
-- 조인 컬럼은 사원 테이블은 '사원번호', 고객 테이블은 '관리자사원번호'이다.
SELECT /* ordered use_merge(c) */
	...
FROM 사원 e, 고객 c
WHERE c.관리자사원번호 = e.사원번호
AND e.입사일자 >= '19960101'
AND e.부서코드 >= 'Z123'
AND c.최종주문금액 >= 20000

-- 양쪽 집합을 조인 컬럼 기준으로 정렬하면 다음과 같다.

-- 사원 데이터를 조인컬럼인 사원번호 기준으로 정렬
-- 정렬한 결과집합은 PGA 영역에 할당한 Sort Area에 저장된다. 크기가 너무 크면 Temp 테이블스페이스에 저장된다.
SELECT
	...
FROM 사원
WHERE 입사일자 >= '19960101'
AND 부서코드 >= 'Z123'
ORDER BY 사원번호
-- 고객 데이터를 조인컬럼인 관리자사원번호 기준으로 정렬
SELECT
	...
FROM 고객
WHERE 최종주문금액 >= 20000
ORDER BY 관리자사원번호 

-- PGA에 저장한 사원 데이터를 스캔하면서 PGA에 저장한 고객 데이터와 조인한다.
```

### @ 소트 머지 조인이 빠른 이유
소트 머지 조인은 Sort Area에 미리 정렬해 둔 자료구조를 이용한다는 점만 다를 뿐 조인 프로세싱 자체는 NL 조인과 같다.<br>
NL 조인은 인덱스를 이용하여 SGA를 사용하지만 소트 머지 조인은 PGA을 사용하여 Latch 획득 과정이 없어 빠르다.<br>

## 4.3 해시 조인

### @ 해시 조인의 기본 매커니즘
해시 조인은 작은 쪽 테이블을 읽어 해시 테이블을 생성하고 큰 쪽 테이블을 읽어 해시 테이블을 탐색하면서 조인한다.

```sql
-- use_hash : 해시 조인을 사용하라는 의미이다.
-- ordered를 명시하였으므로 먼저 읽은 사원 테이블을 기준으로 해시 맵을 생성
-- swap_join_inputs(e) 힌트를 사용하면 명시한 테이블 기준으로 해시 맵을 생성
SELECT /* ordered use_hash(c) */
	...
FROM 사원 e, 고객 c
WHERE c.관리자사원번호 = e.사원번호
AND e.입사일자 >= '19960101'
AND e.부서코드 >= 'Z123'
AND c.최종주문금액 >= 20000

-- 사원 테이블을 읽어 해시 맵을 생성
-- 조인 컬럼인 사원번호를 해시 맵의 키 값으로 사용
SELECT
	...
FROM 사원
WHERE 입사일자 >= '19960101'
AND 부서코드 >= 'Z123

-- 고객 테이블을 하나씩 읽어 앞서 생성한 해시 맵을 탐색
-- 관리자사원번호를 해시 함수에 입력
SELECT
	...
FROM 고객
WHERE 최종주문금액 >= 20000
```

### @ 해시 조인이 빠른 이유
해시 조인이 인덱스 기반의 NL 조인보다 빠른 이유는 해시 테이블을 PGA 영역에 할당하기 때문이다.<br>
NL 조인은 Outer 테이블 레코드마다 Inner 쪽 테이블 레코드를 읽기 위해 래치 획득 및 캐시버퍼 체인 스캔 과정을 반복하지만 해시 조인은 래치 획득 과정 ㅇ벗이 PGA에서 빠르게 데이터를 탐색하고 조인한다.

> 해시 테이블에 조인 키값만 저장된다고 아는 사람이 많은데 키값만 저장한다면 ROWID로 다시 테이블 블록을 액세스해야 하는 문제가 생긴다.<br>
> 따라서 해시 테이블에는 조인 키값뿐만 아니라 SQL에 사용한 컬럼을 모두 저장한다.

소트 머지 조인과 해시 조인 모두 대량의 데이터를 조인할 때 사용하지만 일반적으로 해시 조인이 더 빠르다.

해시 조인은 NL 조인처럼 조인 과정에서 발생하는 랜덤 액세스 부하가 없고 소트 머지 조인처럼 양쪽 집합을 미리 정렬하는 부하도 없다. <br>
해시 테이블을 생성하는 비용이 수반되지만 둘 중 작은 집합을 Build Input으로 선택하므로 대개는 부담이 크지 않다.

### @ 대용량 Build Input 처리
해시 조인을 하려고 작은 테이블을 찾을려 하였지만 둘 다 대용량일 경우에는 DBMS는 분할 정복 방식을 사용한다. <br>
작은 테이블을 여러 개의 파티션으로 나누어 해시 테이블을 생성하고 큰 테이블을 여러 개의 파티션으로 나누어 해시 테이블을 탐색한다.

## 4.4 서브쿼리 조인
### @ 서브쿼리와 조인
메인쿼리와 서브쿼리 간에는 부모와 자식이라는 종석적이고 계층적인 관계가 존재한다.
### @ 필터 오퍼레이션
`no_unnest` 힌트를 사용하면 서브쿼리를 풀어내지 않고 그대로 수행하라고 옵티마이저에게 지시한다.
```sql
SELECT 
	...
FROM 고객 c
WHERE c.가입일시 >= '19960101'
AND EXISTS (
	SELECT /*+ no_unnest */ 
    	'x'
	FROM 거래
	WHERE 고객번호 = c.고객번호
	AND 거래일시 >= '20210621'  
)
```
필터 오퍼레이션은 기본적으로 NL조인과 처리 루틴이 같다. 따라서 Filter는 Nested loop로 치환하고 해석해도 무방하다. <br>
그럼에도 차이가 있는데
1. 필터는 메인쿼리의 한 로우가 서브쿼리의 한 로우와 조인에 성공하면 진행을 순간 멈추고 메인쿼리의 다음 로우를 계속 처리한다.
2. 필터는 캐싱기능을 가진다. 즉, 서브쿼리 입력 값에 따른 반환값(true, false)를 가진다.
3. 필터 서브쿼리는 일반 Nl조인과 달리 메인쿼리에 종속되므로 조인 순서가 고정된다.

### @ 서브쿼리 Unnesting
서브쿼리 Unnesting은 메인과 서브쿼리 간의 계층구조를 풀어 서로 같은 레벨로 만들어준다는 의미에서 '서브쿼리 Flattening'이라고 부르기도 한다.  <br>
서브쿼리를 그대로 두면 필터 방식을 사용할 수 밖에 없지만 Unnesting을 하고 나면 일반 조인문처럼 다양한 최적화 기법을 사용할 수 있다. <br>

### @ 인라인 뷰 서브 쿼리와 조인
일반적으로 서브 쿼리가 포함된 쿼리는 옵티마이저는 각각의 쿼리를 나눠서 쿼리 변환을 하여 각각에 대해 더 나은 성능을 내도록 한다. <br>
인라인 뷰도 옵티마이저가 독립적으로 최적화하기 때문에 merge 힌트를 사용하여 다르게 처리할 수 있다.
```sql
-- T에 대한 인라인 뷰 안에서는 조건에 해당하는 모든 데이터를 읽어야 한다.
-- 모든 데이터를 읽고 결국엔 고객 테이블의 고객번호와 조인되는 값만 출력한다.
-- 따라서 불필요한 데이터를 조회해서 비효율적이다.
SELECT 
	...
FROM 고객 C
	,(SELECT ... FROM 거래 WHERE 거래일시 >= trunc(sysdate, 'mm') GROUP BY 고객번호) T
WHERE C.가입일시 >= trunc(add_months(sysdate, -1), 'mm')
	AND T.고객번호 = C.고객번호
    
    
-- merge : 뷰를 메인 쿼리와 머지하라는 힌트이다.
-- 머지를 하게되면 고객 테이블을 먼저 읽고 조인할 때는 해당 고객들에 대한 데이터만 읽는다.
SELECT 
	...
FROM 고객 C
	,(SELECT /*+ merge */ ... FROM 거래 WHERE 거래일시 >= trunc(sysdate, 'mm') GROUP BY 고객번호) T
WHERE C.가입일시 >= trunc(add_months(sysdate, -1), 'mm')
	AND T.고객번호 = C.고객번호
```

### @ 스칼라 서브쿼리와 조인
- 스칼라 서브 쿼리는 NL 조인 방식으로 실행된다.
- 필터 서브 쿼리처럼 스칼라 서브 쿼리도 캐싱 기능을 사용하여 동일한 입력값에 대해서 캐싱해놓는다.
- 스칼라 서브 쿼리는 2개 이상의 항목을 조회할 수 없으므로 그럴 경우에는, 해당 쿼리를 인라인 뷰로 사용하는 편이 낫다.
- 스칼라 서브 쿼리도 unnest 사용이 가능하다.