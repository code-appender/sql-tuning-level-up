# 6. DML 튜닝 2

## 6.3 파티션을 활용한 DML 튜닝

### 테이블 파티션
파티션을 이용하면 대량 추가/삭제/변경 작업을 빠르게 처리할 수 있다.

파티셔닝은 테이블 또는 인덱스 데이터를 특정 컬럼(파티션 키) 값에 따라 별도 세그먼트에 나눠서 저장하는 것을 말한다.

#### 파티션이  필요한 이유
1. 관리 : 파티션 단위 백업, 추가, 삭제, 변경 -> 가용성 향상 
2. 성능 : 파티션 단위 조회 및 DML, 경합 또는 부하 분산

#### Range 파티션
Range 파티션은 오라클 8버전부터 제공된 가장 기초적인 방식으로 주로 날짜 컬럼을 기준으로 파티셔닝한다. 

파티션 테이블에 대한 SQL 성능 향상 원리는 파티션 Prunning에 있다.
<br> 파티션 Prunning은 SQL 하드파싱이나 실행 시점에 조건절을 분석해서 읽지 않아도 되는 파티션 세그먼트를 액세스 대상에서 제외하는 기능이다.

파티션과 병렬처리가 만나면 효과는 배가된다.

#### 해시 파티션
해시 파티션은 Range 파티션에 이어 오라클 8i 버전부터 제공된 파티션 방식이며
<br>
파티션 키 값을 해시 함수에 입력해서 반환받은 값이 같은 데이터를 같은 세그먼트에 저장하는 방식이다.
<br> 
파티션 개수는 사용자가 결정하고 해시함수는 오라클 내부 함수를 사용한다.

#### 리스트 파티션
사용자가 정의한 그룹핑 기준에 따라 데이터를 분할 저장하는 방식이다.
<br> 가능한 한 각 파티션에 값이 고르게 분산될 수 있도록 구성해야 한다.

### 인덱스 파티션
인덱스는 다음과 같이 구성될 수 있다.
- 파티션 인덱스
  - 로컬 파티션 인덱스 : 각 테이블 파티션과 인덱스 파티션이 1:1 대응관계를 유지, 인덱스 문 뒤에 'LOCAL' 옵션을 추가한다.
  - 글로벌 파티션 인덱스 : 로컬이 아닌 모든 파티션 인덱스
  - 비파티션 인덱스
- 비파티션 인덱스

### 로컬 파티션 인덱스와 글로벌 파티션 인덱스의 차이
로컬 파티션 인덱스는 오라클이 자동으로 파티션을 관리해주기 때문에 테이블 파티션 구성을 변경하더라도 인덱스를 변경할 필요가 없다.
<br> 하지만 글로벌 파티션 인덱스는 테이블 파티션 구성을 변경하는 순간 Unusable 상태로 바뀌므로 곧바로 인덱스를 재생성해줘야 하며 그동안 해당 테이블을 사용하는 서비스를 중지해야 한다.

### Prefixed VS Nonprefixed
파티션 인덱스를 파티션 키 컬럼이 인덱스 구성 상 왼쪽 선두 컬럼에 위치하는지에 따라 Prefixed와 Nonprefixed로 구분할 수 있다.

- Prefixed : 파티션 키 컬럼이 인덱스 구성 상 왼쪽 선두에 위치
- Nonprefixed : 파티션 키 컬럼이 인덱스 구성 상 왼쪽 선두에 위치하지 않음. 파티션 키가 인덱스 컬럼에 아예 속하지 않는 경우도 포함.

글로벌 파티션 인덱스는 Prefixed 파티션만 지원된다는 것을 기억해야 한다.

#### 중요한 인덱스 파티션 제약
> "Unique 인덱스를 파티셔닝하려면 파티션 키가 모두 인덱스 구성 컬럼이어야 한다."

이유는 파티션 키 없이 PK 컬럼만으로 조회할 떄 모든 파티션 인덱스를 탐색해야 하기 때문이다.

이 제약의 문제점은 PK 인덱스를 로컬 파티셔닝하지 못하면 파티션 Drop, Truncate 같은 파티션 구조 변경 작업이 쉽지 않다는 것이다.
<br> 이들 작업을 수행하는 순간 PK 인덱스가 Unusable 상태로 바뀌기 때문이다.
<br> 서비스 중단 없이 파티션 구조를 빠르게 변경하기 위해서는 PK를 포함한 모든 인덱스가 로컬 파티션 인덱스여야 한다.

### 파티션을 활용한 대량 UPDATE 튜닝
인덱스가 DML 성능에 큰 영향을 미치므로 대량 데이터릉ㄹ 입력/수정/삭제할 때는 인덱스를 Drop하거나 Unusable 상태로 변경하고서 작업하는 방법을 많이 사용한다.
<br> 일반적으로 손익분기점은 5%이다. 변경하고자 하는 데이터의 비중이 5%를 넘으면 인덱스를 그대로 둔 상태에서 작업하기보다 인덱스없이 작업한 후에 재생성하는 것이 더 빠르다는 것이다.

### 파티션을 활용한 대량 DELETE 튜닝

### 파티션 Exchange를 이용한 대량 데이터 변경
테이블이 파티셔닝돼 있고 인덱스도 로컬 파티션이라면 파티션 Exchange를 이용해 대량 데이터 변경 작업을 빠르게 처리할 수 있다.
<br> 수정된 값을 가지는 임시 세그먼트를 만들어 원본 파티션과 바꿔치기하는 방식이다.

1. 임시 테이블을 생성하며 될 수 있다면 nologging 모드로 생성한다.
2. 거래 데이터를 읽어 임시 테이블에 입력하면서 상태코드 값을 수정한다.
3. 임시 테이블에 원본 테이블과 같은 구조로 인덱스를 생성한다. 이 또한 nologging 모드로 생성한다.
4. 원본 테이블의 파티션을 Exchange한다.
5. 임시 테이블을 Drop한다.
6. 파티션을 logging 모드로 전환한다.

### 파티션 Drop
테이블이 삭제 조건절 컬럼 기준으로 파티셔닝 되어 있고 인덱스가 로컬 파티션이라면 파티션 drop으로 대량의 데이터를 간단하게 삭제할 수 있다.

### 파티션 Truncate
삭제 조건이 파티셔닝된 컬럼 외에 다른 컬럼들이 포함된다면 대량 데이터를 지울게 아니라 남길 데이터만 백업했다가 재입력하는 방식이 빠르다.
<br> 이때 파티션 Truncate를 사용하면 된다. 

### 파티션을 활용한 대량 INSERT 튜닝
#### 비파티션 테이블일 때
비파티션 테이블일 떄 손익분기점을 넘는 대량 데이터를 INSERT 하려면 인덱스를 Unusable 시켰다가 재생성하는 방식이 더 빠를 수 있다.
#### 파티션 테이블일 때
실무에서는 대량의 인덱스를 재생성하는 부담이 크기에 왠만하면 인덱스를 그대로 둔 상태로 INSERT하지만 테이블이 파티셔닝 되어 있고 인덱스도 로컬 파티션이라면 파티션 단위로 인덱스를 재생성할 수 있기 때문에 인덱스 파티션을 Unusable 상태로 전환해도 된다.

## 6.4 Lock과 트랜잭션 동시성 제어
### DML 로우 Lock
DML Lock은 다중 트랜잭션이 동시에 액세스하는 사용자 데이터의 무결성을 보호해 준다.
<br> DML Lock은 테이블 Lock과 로우 Lock이 있다.

### DML 로우 Lock
DML 로우 Lock은 두 개의 동시 트랜잭션이 같은 로우를 변경하는 것을 방지한다. 하나의 로우를 변경하려면 로우 Lock을 먼저 설정해야 한다.

INSERT에 대한 로우 Lock 경합은 Unique 인덱스가 있을 때만 발생한다. 즉, Unique 인덱스가 있는 상황에서 두 트랜잭션이 같은 값을 입력하려고 할 때 블로킹이 발생한다.

MVCC 모델을 사용하는 오라클은 SELECT 문에 로우 Lock을 사용하지 않는다. 다시 말하면, 오라클은 다른 트랜잭션이 변경한 로우를 읽을 때 복사본 블록을 만들어서 쿼리가 시작된 시점으로 되돌려서 읽는다.

### DML 테이블 Lock
오라클은 DML 로우 Lock을 설정하기 전에 테이블 lock을 먼저 설정하며 이 테이블 lock에는 여러 가지 lock 모드가 있으며 서로의 호환성이 다르다.
<br> 선행 트랜잭션과 호환되지 않는 모드로 테이블 Lock을 설정하려는 후행 트랜잭션은 대기하거나 작업을 포기해야 한다.

### Lock을 푸는 열쇠, 커밋
블로킹과 교착상태는 다르다.
<br> 블로킹은 선행 트랜잭션이 설정한 Lock 때문에 후행 트랜잭션이 작업을 진행하지 못하는 상태이며 교착상태는 두 트랜잭션이 각각 특정 리소스에 lock을 설정한 상태에서 맞물리는 것이다.

블로킹을 해결하는 방법은 커밋 뿐이지만 교착상태는 여러 방법이 존재한다.

트랜잭션의 길이 또한 중요한데 트랜잭션을 너무 길게 정의하면 롤백해야 할 때 너무 많은 시간이 소요될 수 있다. 또한, 트랜잭션이 너무 짧아서
불필요하게 커밋을 너무 자주 수행하면 부하가 발생할 수 있다. 
<br> 하지만 잦은 커밋이 고민이 된다면 비동기식 커밋과 배치 커밋을 활용해볼 수 있다.

### 트랜잭션 동시성 제어
동시성 제어는 비관적 동시성 제어와 낙관적 동시성 제어로 나뉜다.
- 비관적 동시성 제어 : 사용자들이 같은 데이터를 동시에 수정할 것으로 가정하여 한 사용자가 데이터를 읽는 시점에 lock을 걸고 조회 또는 갱신처리가 완료될 때까지 이를 유지한다.
- 낙관적 동시성 제어 : 사용자들이 같은 데이터를 동시에 수정하지 않을 것으로 가정하며 데이터를 읽을 때 Lock을 설정하지 않는다. 하지만 데이터를 수정하고자 하는 시점에 앞서 읽은 데이터가 다른 사용자에 의해 변경되었는지 반드시 검사해야 한다.

비관적 동시성 제어를 사용하며 WAIT 또는 NOWAIT 옵션을 사용하면 다른 트랜잭션에 의해 Lock이 걸렸을 경우 Exception을 만나게 되므로 이를 활용할 수 있다.

낙관적 동시성 제어를 사용하는 경우에도 다른 사용자에 의해 데이터가 변경되었는지 확인해야 하므로 이를 활용하여 Exception을 활용할 수 있다.

