# 6. DML 튜닝2

# 6.3 파티션을 활용한 DML 튜닝

- 파티션을 이용하면 대량 추가 / 변경 / 삭제 작업을 빠르게 처리할 수 있다.

## 6.3.1 테이블 파티션

<aside>
💡 파티셔닝(Partitioning)은 테이블 또는 인덱스 데이터를 특정 컬럼(파티션 키) 값에 따라 별도 세그먼트에 나눠서 저장하는 것을 말한다.

</aside>

- 데이터도 월별, 분기별, 반기별, 연별로 분할해서 저장해 두면 빠르게 조회할 수 있고 관리하기도 쉽다.
- 일반적으로 시계열에 따라 Range 방식으로 분할하지만, 그 외 다른 기준(리스트 또는 해시 방식)으로 분할할 수 있다.
- 파티션에는 Range, 해시, 리스트 세 종류가 있다.
- 관련 있는 데이터가 흩어지지 않고 물리적으로 인접하도록 저장하는 클러스터링 기술에 속한다.

### 파티션이 필요한 이유

- 관리적 측면:
    - 파티션 단위 백업, 추가, 삭제, 변경 → 가용성 향상
- 성능적 측면:
    - 파티션 단위 조회 및  DML, 경합 또는 부하 분산

### (1) Range 파티션

- 가장 기초적인 방식으로 주로 ‘날짜 컬럼을 기준’으로 파티셔닝한다.
- 각 레코드를 파티션 키 값에 따라 분할 저장하고, 읽을 때도 검색 조건을 만족하는 파티션만 골라 읽을 수 있어 이력성 데이터를 Full Scan 방식으로 조회할 때 성능을 크게 향상한다.
- 보관주기 정책에 따라 과거 데이터가 저장된 파티션만 백업하고 삭제하는 등 데이터 관리 작업을 효율적이고 빠르게 수행할 수 있는 장점도 있다.

### (2) 해시 파티션

- 파티션 키 값을 해시 함수에 입력해서 반환받은 값이 같은 데이터를 같은 세그먼트에 저장하는 방식이다.
- 파티션 개수만 사용자가 결정하고 데이터를 분산하는 알고리즘은 오라클 내부 해시함수가 결정한다.
- 해시 파티션은 고객ID처럼 변별력이 좋고 데이터 분포가 고른 컬럼을 파티션 기준으로 선정해야 효과적이다.
- 해시 알고리즘 특성상 등치(=) 조건 또는 IN-List 조건으로 검색할 때만 파티션 Pruning이 작동한다.

### (*) 파티션 Pruning?

- 파티션 테이블에 대한 SQL 성능 향상 원리는 파티션 Pruning에 있다.
- ‘prune’은 ‘쓸데없는 가지를 치다’, ‘불필요한 부분을 제거한다’는 뜻을 가진다.
- 파티션 Pruning은 SQL 하드파싱이나 실행 시점에 조건절을 분석해서 읽지 않아도 되는 파티션 세그먼트를 액세스 대상에서 제외하는 기능이다.

### (3) 리스트 파티션

- 사용자가 정의한 그룹핑 기준에 따라 데이터를 분할 저장하는 방식이다.
- 지역분류 기준으로 인터넷 매물 테이블을 리스트 파티셔닝하는 방법을 예시한다.
    - P_지역1 → 서울
    - P_지역2 → 경기, 인천
    - P_지역3 → 부산, 대구, 대전, 광주
    - P_기타 → 기타 지역
- Range 파티션에선 값의 순서에 따라 저장할 파티션이 결정되지만, 리스트 파티션에는 순서와 상관없이 불연속적인 값의 목록에 의해 결정된다.
- 해시 파티션과 비교하면, 해시 파티션은 오라클이 정한 해시 알고리즘에 따라 임의로 분할하는 반면, 리스트 파티션은 사용자가 정의한 논리적인 그룹에 따라 분할한다.
- 각 파티션에 값이 고르게 분산되도록 해야한다.

## 6.3.2 인덱스 파티션

- 테이블 파티션과 인덱스 파티션은 구분돼야 한다.
- 인덱스 파티션은 테이블 파티션과 맞물려 다양한 구성이 존재한다.
- 다양한 인덱스 파티션 구성을 설명하기 위해 우선 테이블 파티션을 다음과 같이 구분하자.
    - 비파티션 테이블(Non_Partitioned Table)
    - 파티션 테이블(Partitioned Table)
- 인덱스도 테이블처럼 파티션 여부에 따라 파티션 인덱스와 비파티션 인덱스로 나뉘고, 파티션 인덱스는 각 파티션이 커버하는 테이블 파티션 범위에 따라 로컬과 글로벌로 나뉜다.
    - 로컬 파티션 인덱스
    - 글로벌 파티션 인덱스
    - 비파티션 인덱스

### (1) 로컬 파티션 인덱스

- 각 테이블 파티션과 인덱스 파티션이 서로 1:1 대응 관계가 되도록 오라클이 자동으로 관리하는 파티션 인덱스를 말한다.
- 로컬이 아닌 파티션 인덱스는 ‘모두’ 글로벌 파티션 인덱스이며, 테이블 파티션과 독립적인 구성(파티션 키, 파티션 기준값 정의)을 갖는다.
- 인덱스 파티션은 테이블 파티션 속성을 그대로 상속받는다.
- 로컬 파티션 인덱스는 테이블과 정확히 1:1 대응 관계를 갖도록 ‘오라클이 파티션을 자동으로 관리’해준다.
- 테이블 파티션 구성을 변경하더라도 인덱스를 재생성할 필요가 없다.
- 변경작업이 순식간에 끝나므로 피크 시간대만 피하면 서비스를 중단하지 않고도 작업할 수 있다.
- 로컬 파티션 인덱스의 장점은 이처럼 관리 편의성에 있다.

### (2) 글로벌 파티션 인덱스

- 테이블과 다르게 구성한 인덱스다.
- 구체적으로, 파티션 유형이 다르거나 파티션 키가 다르거나 파티션 기준값 정의가 다른 경우다.
- 비파티션 테이블이어도 인덱스는 파티셔닝할 수 있다.
- 글로벌 파티션 인덱스는 테이블 파티션 구성을 변경하는 순간 Unusable 상태로 바뀌므로 곧바로 인덱스를 재생성해 줘야 한다.
- 테이블과 인덱스가 정확히 1:1 관계까 되도록 DB 관리자가 파티션을 직접 구성할 수도 있지만, 그렇다고 그것이 로컬 파티션은 아니다.
    - 오라클이 인덱스 파티션을 자동으로 관리해주지 않기 때문이다.

### (3) 비파티션 인덱스

- 말 그대로 파티셔닝하지 않은 인덱스다.
- 여러 테이블 파티션을 가리킨다.
- 그런 의미에서 비파티션 인덱스를 ‘글로벌 비파티션 인덱스’라고 부르기도 한다.
- 비파티션 인덱스는 테이블 파티션 구성을 변경하는 순간 Unusable 상태로 바뀌므로 곧바로 인덱스를 재생성해 줘야 한다. 그동안 해당 테이블을 사용하는 서비스를 중단해야 한다.

### Prefixed vs Nonprefixed

- 파티션 인덱스를 위 제목처럼 나눌 수 있다. 이는 인덱스 파티션 키 컬럼이 인덱스 구성상 왼쪽 선두 컬럼에 위치하는지에 따른 구분이다.
- Prefixed:
    - 인덱스 파티션 키 컬럼이 인덱스 키 컬럼 왼쪽 선두에 위치한다.
- Nonprefixed:
    - 인덱스 파티션 키 컬럼이 인덱스 키 컬럼 왼쪽 선두에 위치하지 않는다.
    - 파티션 키가 인덱스 컬럼에 아예 속하지 않을 때도 여기에 속한다.

### 중요한 인덱스 파티션 제약

<aside>
💡 Unique 인덱스를 파티셔닝 하려면, 파티션 키가 모두 인덱스 구성 컬럼이어야 한다.
p.455 예시 참고

</aside>

## 6.3.3 파티션을 활용한 대량 UPDATE 튜닝

- 인덱스가 DML 성능에 큰 영향을 미치므로 대량 데이터를 입력 / 수정 / 삭제할 때는 (6.1.4)에서 본 것처럼 인덱스를 Drop 하거나 Unusable 상태로 변경하고서 작업하는 방법을 많이 활용한다.
- 입력 / 수정 / 삭제하는 데이터 비중이 5%를 넘는다면, 인덱스를 그대로 둔 상태에서 작업하기보다 인덱스 없이 작업한 후에 재생성하는 것이 더 빠르다.
- 10억건이 저장되어있는 테이블에서 5,000만 건을 수정하기 위해 10억 건짜리 인덱스를 Drop했다가 재생성할 것인가. 10억 건 인덱스를 재생성하는 데 걸리는 시간도 만만치 않다.
- 이 지점에서 고민이 생긴다.
- 이 정도 대용량 테이블이라면 인덱스를 그대로 둔 상태에서 작업하는 경우가 많다. 인덱스 전체를 재생성해야 하는 부담이 그만큼 크기 때문이다.

### 파티션 Exchange를 이용한 대량 데이터 변경

- 테이블이 파티셔닝돼 있고 인덱스도 다행이 로컬 파티션이라면, 좋은 해법이 있다.
- 수정된 값을 갖는 임시 세그먼트를 만들어 원본 파티션과 바꿔치기하는 방식이다.

## 6.3.4 파티션을 활용한 대량 DELETE 튜닝

UPDATE 인덱스 재생성과 DELETE 인덱스 재생성 차이?

### 파티션 Drop을 이용한 대량 데이터 삭제

- 테이블이 삭제 조건절 컬럼 기준으로 파티셔닝돼 있고 인덱스도 로컨 파티션이라면 대량 데이터를 순식간에 삭제할 수 있다.

### 파티션 Truncate를 이용한 대량 데이터 삭제

- 삭제 조건이 여러개 일 때, 데이터가 소수이면 DELETE문을 그대로 사용한다.
- 데이터가 대다수이면, 대량 데이터를 지울 게 아니라 남길 데이터만 백업했다가 재입력하는 방식이 빠르다.

### 서비스 중단없이 파티션을 Drop 또는 Truncate 하려면?

- 파티션 키와 커팅 기준 컬럼이 일치해야 함
    - ex) 파티션 키와 커팅 기준 컬럼이 모두 ‘신청일자’
- 파티션 단위와 커팅 주기가 일치해야 함
    - ex) 월 단위 파티션을 월 주기로 커팅
- 모든 인덱스가 로컬 파티션 인덱스이어야 함
    - ex) 파티션 키는 ‘신청일자’, PK는 ‘신청일자 + 신청순번’
    - PK 인덱스는 지금처럼 삭제 기준(파티션 키) 컬럼이 인덱스 구성 컬럼이어야 로컬 파티셔닝 가능

## 6.3.5 파티션을 활용한 대량 INSERT 튜닝

### 비파티션 테이블일 때

- 손익분기점을 넘는 대량 데이터를 INSERT 하려면, 인덱스를 Unusable 시켰다가 재생성하는 방식이 더 빠를 수 있다.
- 초대용량 인덱스를 재생성하는 부담이 만만치 않기 때문에 시간이 더 오래 걸리더라도 웬만하면 인덱스를 그대로 둔 상태로 INSERT 한다.

### 파티션 테이블일

- 테이블이 파티셔닝, 인덱스도 로컬 파티션이라면 고민 해결이다.
- 파티션 단위로 인덱스를 재생성할 수 있기 때문이다.

---

# 6.4 Lock과 트랜잭션 동시성 제어

## 6.4.1 오라클 Lock

- DML Lock, DDL Lock, 래치, 버퍼 Lock, 라이브러리 캐시 Lock/Pin 등 다양한 종류의 Lock을 사용한다.
- 래치는 SGA에 공유된 각종 자료구조를 보호하기 위해 사용하며
- 버퍼 Lock은 버퍼 블록에 대한 액세스를 직렬화하기 위해 사용한다.
- `DML Lock이 가장 중요하다.`
- DML Lock은 다중 트랜잭션이 동시에 액세스하는 사용자 데이터의 무결성을 보호해준다.
- DML Lock에는 테이블 Lock과 로우 Lock이 있다.

### DML 로우 Lock

- DML 로우 Lock은, 두 개의 동시 트랜잭션이 같은 로우를 변경하는 것을 방지한다. 하나의 로우를 변경하려면 로우 Lock을 먼저 설정해야 한다.
- 어떤 DBMS이든지 DML 로우 Lock에는 배타적 모드를 사용하므로 UPDATE 또는 DELETE를 진행 중인(아직 커밋하지 않은) 로우를 다른 트랜잭션이 UPDATE하거나 DELETE 할 수 없다.
- INSERT에 대한 로우 Lock 경합은 Unique 인덱스가 있을 때만 발생한다. 즉, Unique 인덱스가 있는 상황에서 두 트랜잭션이 같은 값을 입력하려고 할 때, 블로킹이 발생한다.
- 블로킹이 발생하면, 후행 트랜잭션은 기다렸다가 선행 트랜잭션이 커밋하면 INSERT에 실패하고, 롤백하면 성공한다.
- 두 트랜잭션이 서로 다른 값을 입력하거나 Unique 인덱스가 아예 없으면, INSERT에 대한 로우 Lock 경합은 발생하지 않는다.
- MVCC 모델을 사용하는 오라클은 SELECT 문에 로우 Lock을 사용하지 않는다.
    - MVCC 모델은 (6.1.1)에 설명
- MVCC 모델을 사용하지 않는 DBMS는 SELECT 문에 공유 Lock을 사용한다.
- SELECT가 서로 진행을 방해할 수 있다.

### DML 테이블 Lock

- 오라클은 DML 로우 Lock을 설정하기에 앞서 테이블 Lock을 먼저 설정한다.
- 현재 트랜잭션이 갱신 중인 테이블 구조를 다른 트랜잭션이 변경하지 못하게 막기 위해서다.
- 테이블 Lock을 ‘TM Lock’이라고 부르기도 한다.

### Lock을 푸는 열쇠, 커밋

- 블로킹은 선행 트랜잭션이 설정한 Lock 때문에 후행 트랜잭션이 작업을 진행하지 못하고 멈춰 있는 상태를 말한다.
- 이것을 해소하는 방법은 커밋(또는 롤백)뿐이다.
- 교착상태(Deadlock)와 헷갈리지 말자.

## 6.4.2 트랜잭션 동시성 제어

- 비관적 동시성 제어(Pessimistic Concurrency Control)
    - 사용자들이 같은 데이터를 동시에 수정할 것으로 가정한다.
    - 따라서 한 사용자가 데이터를 읽는 시점에 Lock을 걸고 조회 또는 갱신처리가 완료될 때까지 이를 유지한다.
    - Lock은 첫 번째 사용자가 트랜잭션을 완료하기 전까지 다른 사용자들이 같은 데이터를 수정할 수 없게 만들기 때문에 비관적 동시성 제어를 `잘못 사용하면` 동시성이 나빠진다.
- 낙관적 동시성 제어(Optimistic Concurrency Control)
    - 사용자들이 같은 데이터를 동시에 수정하지 않을 것으로 가정한다.
    - 따라서 데이터를 읽을 때 Lock을 설정하지 않는다.
    - 데이터를 수정하고자 하는 시점에서 앞서 읽은 데이터가 다른 사용자에 의해 변경되었는지 반드시 검사해야 한다.

## 6.4.3 채번 방식에 따른 INSERT 성능 비교

- 신규 데이터를 입력하려면 PK 중복을 방지하기 위한 채번이 선행되어야 하는데, 가장 많이 사용하는 아래 세 가지 채번 방식의 성능과 장단점을 비교해 보자.
    - 채번 테이블
    - 시퀀스 오브젝트
    - MAX + 1 조회
- PK가 (상담원ID + 상담일자 + 상담순번)처럼 복합컬럼으로 구성돼 있을 때, 순번 이외의 컬럼(상담원ID, 상담일자)을 지금부터 ‘구분 속성’이라고 부르기로 하자.