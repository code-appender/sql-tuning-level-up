## 6.3 파티션을 활용한 DML 튜닝

###  테이블 파티션

파티셔닝 : 테이블 또는 인덱스 데이터를 특정 컬럼 값에 따라 별도 세그먼트에 나눠서 저장하는것을 말한다.

일반적으로는 시계열에 따라 분할 하지만 리스트, 해시 방식으로 분리할 수 있다.

파티셔닝을 하는 이유는

1. 관리적 측면 : 파티션 단위 백업, 추가, 삭제, 변경 → 가용성 향상
2. 성능적 측명 : 파티션 단위 조회 및 DML 정합 또는 부하분산

파티션의 세종류

- Range 파티션
    - 일반 적으로 날짜 단위
    - 검색 조건을 만족하는 파티션만 골라 읽어 FUll Scan방식보다 성능이 향상된다.
    - 또한 보관주기 정책에 따라 특정 파티션만 삭제하고 백업하는 등 데이터 관리 작업을 효율적이고 빠르게 수행할 수 있따다
    - 파티션의 성능향상 원리는 Pruning 에 있다. 하드 파싱이나 실행 시점에 조건절을 분석해서 읽지 않아도 되는 파티션 세그먼트를 액세스 대상에서 제외하는 기능이다.
- 해시
    - 해시 파티션은 고객 ID처럼 번별력이 좋고 분포가 고른 컬럼을 기준으로 선정하는 것이 좋다.
- 리스트
    - 사용자가 정의한 그룹핑 기준에 따라 데이터를 분할 저장하는 방식이다.
    - 값의 순서와 상관 없이 불연속적인 값의 목록에 의해 결정된다.

### 인덱스 파티션

테이블 파티션 vs 인덱스 파티션

인덱스 파티션은 테이블 파티션과 맞물려 다양한 구성이 존재한다.

- 비 파티션 테이블
- 파티션 테이블

인덱스도 테이블처럼 파티션 여부에 따라 파티션 인덱스와 비 파티션 인덱스로 나누고 파티션 인덱스는 각 파티션이 커버하는 테이블 파티션 범위에 따라 로컬과 글로벌로 나뉜다.

- 로컬 파티션 인덱스 (1:1 대응)
    - ex로 각 계졀별로 옷을 정리해논 것 안에서 계절별로 별도 색인을 만드는 것이다.
    - 1:1 (인덱스와 테이블) 오라클의 자동관리
    - 서비스를 중단하지 않고도 작업할 수 있어 관리가 편의 한다.
- 클로벌 파티션 인덱스
    - 글로벌 파티션은 데이블 파티션 구성을 변경하는 순간 인덱스를 재 생성해주어야 한다.  이에 사용하는 순간 정지해야한다
- 비 파티션 인덱스
    - 파티셔닝 하지 않은 인덱스로 Create Index ~~ on ( ID) 와 같이 생성하는 경우이다.

파티션 인덱스

- Prefixed
    - 인덱스 파티션 키 컬럼이 인덱스 키 컬럼 왼쪽 선두에 위치한다.
- Nonprefixed
    - 인덱스 파티션 키 컬럼이 인덱스 키 컬럼 왼쪽 선두에 위치하지 않는다. 파티션 키가 인덱스 컬럼에 아예 속하지 않을떄도 여기에 속한다.

> Unique 인덱스를 파티셔닝 하려면 파티션 키가 모두 인덱스 구성 컬럼이어야 한다.
>

## 6.4 Lock 과 트랜잭션 동시성 제어

### 오라클 락

DML LOCK

- 테이블 락
    - 테이블 락은 정말로 테이블 단위로 락을 거는 것이 아닌 일종의 푯말이다.
- 로우 락
    - 두 개의 트랜잭션이 같은 로우를 동시에 변경하려 할 떄
    - unique가 인덱스가 있을때
    - 오라클은 Select 와 DML을 동시에 고려하지 않는다 DML끼리는 서로 방해될 수 있다.

이런 락을 푸는 열쇠는 커밋이다.

블로킹 : 선행 트랜잭션에서 설정한 락때문에 후행 트랜잭션이 작업을 진행하지 못하고 멈춰있는 상태(커밋으로 해결)

교착 상태 : 두 개의 트랜잭션이 각각 특정 리소스에 락을 설정한 상태에서 서로 다른 리소스에 또 락을 걸려고 해서 발생하는 일이다 ( 서로가 자원을 점유한 상태로 서로의 자원을 탐하여 영영 풀리지 못한다), 롤백으로 해결한다. (문제가 생긴 커밋에 대해서)

### 동시성 제어

- 비관성 동시성 제어
    - 락이 걸릴걸 예상하고 진행 ( 잘못 설계시 동시성 문제가 발생할 수 있음)
- 낙과적 동시성 제어
    - 동시에 수정하지 않을것으로 가정한다.
    - 데이터를 읽을때 락을 설정하지 않고 데이터를 수정하고자 하는 시점에 앞서 읽은 데이터가 다른 사용자에 의해 변경되었는지 확인

### 채번 방식에 따른 Insert 성능 비교

- 채번테이블
    - 구분 속성별 순번을 채번하기위해 별도 테이블을 관리하는 방식
    - 장점
        - 범용성이 좋다
        - 인서트 과정에 중복 레코드 발생에 대비한 예외 처리에 크게 신경쓰지 않아도 된다. (vs MAX + 1)
        - 인서트 과정에서 결번을 방지한다 (vs 시퀀스)
        - 기본키가 복합컬럼인 경우에도 사용가능 하다 (vs 시퀀스)
    - 단점
        - 성능문제
- 시퀀스 오브젝트
    - 장점
        - 성능이 빠르다
        - 인서트 과정에 중복 테코드 발생에 대비한 예외처리 고려하지 않아도 된다.
    - 단점
        - 결번이 생길 수 있다. (왜 생기는가 ? 488 P )
        - 복합컬럼에서 사용불가
- MAX + 1 조회
    - 장점
        - 별도의 채번테이블, 시퀀스 테이블 관리 하지 않아도 된다.
        - 동시 트랜잭션에 의한 충돌이 많지 않은경우 성능이 빠르다
        - 복합컬럼에 사용할 수 있따.
    - 단점
        - 레코드 중복에 대비한 세밀한 예외 처리가 필요하다.
        - 다중 트랜잭션에 의한 동시 채번이 심하면 시퀀스 보다 성능이 많이 나빠질 수 있다.