# DML 튜닝

## 파티션을 이용한 DML 튜닝

### 테이블 파티션

**파티션이 필요한 이유**

- 관리적 측면: 파티션 단위 백업, 추가, 삭제, 변경 → 가용성 향상
- 성능적 측면: 파티션 단위 조회 및 DML, 경합 또는 부하 분산

**Range 파티션**

- 가장 기초적인 방식으로 날짜 컬럼을 기준으로 파티셔닝
- 예) 주문일자 기준으로 분기별 Range 파티셔닝 가능
- 검색조건을 만족하는 파티션만 골라 읽어 이력성 데이터를 Full Scan 방식으로 조회 시 성능 크게 향상
- 보관주기 정책에 따라 과거데이터 파티션만 백업, 삭제하는 등 데이터 관리가 효율적이고 빠름

> 파티션 Pruning : Prune 은 불필요한 부분을 제거한다는 의미
>
>
> 파티션 테이블에 대한 SQL 성능 향상 원리는 파티션 Pruning
>
- Full Scan 하더라도 전체가 아닌 일부 파티션 세그먼트만 조회
- 파티션과 병렬처리가 만나면 효과가 증진

**Hash 파티션**

- 파티션 키 값을 해시 함수에 입력해서 반환받은 값이 같은 데이터를 세그먼트에 저장하는 방식
- 파티션 개수만 사용자가 결정, 데이터 분산 알고리즘은 오라클 내부 해시함수가 결정
- 해시 파티션은 고객ID 처럼 **변별력이 좋고 데이터 분포가 고른** 컬럼을 파티션 기준으로 선정해야 효과적
- 해시 알고리즘 특성상 등치(=) 조건 또는 IN-List 조건으로 검색시 파티션 Pruniing 작동

**리스트 파티션**

- 사용자가 정의한 그룹핑 기준으로 데이터를 분할 저장하는 방식
- 순서가 아닌 불연속적인 값의 목록으로 파티션 결정
- 가능하면 각 파티션에 값이 고르게 분산되도록 해야 함

### 인덱스 파티션

- 테이블 파티션과 인덱스 파티션은 구분
    - 비파티션 테이블(Non-Partitioned Table)
    - 파티션 테이블(Partitioned Table)
- 파티션 인덱스는 각 파티션이 커버하는 테이블 파티션 범위에 따라 로컬과 글로벌로 나뉨
    - 로컬 파티션 인덱스(Local Partitioned Index)
        - 각 테이블 파시션과 인덱스 파티션이 서로 1:1 대응 -> 오라클리 자동으로 파티션 인덱스 관리
    - 글로벌 파티션 인덱스(Global Partitioned Index)
        - 로컬이 아닌경우 전부 글로벌이며 테이블 파티션과 인덱스 파티션이 독립적인 구성(파티션 키, 파티션 기준값 정의)을 가짐

**로컬 파티션 인덱스**

- 봄, 여름, 가을, 겨울에 옷장에 옷에 대한 색인이 있는 것
- 인덱스 파티션은 테이블 파티션 속성을 그대로 상속 (테이블 파티션 키가 주문일자면 인덱스 파티션 키도 주문일자)
- 1:1 대응 관계로 오라클이 자동 관리
- 테이블 파티션 구성 변경(add, drop, exchange) 하더라도 인덱스를 재생성할 필요가 없어 서비스 중단없이 작업 가능
- 관리 편의성 매우 좋다

**글로벌 파티션 인덱스**

- 파티션을 테이블과 다르게 구성한 인덱스
- 테이블 파티션 구성을 변경(drop, exchange, split) 하는 순간 Unusable 상태로 바뀌므로 곧바로 인덱스 재생성
- 즉 그동안 서비스 중단이 발생

**비파티션 인덱스**

- 인덱스를 파티셔닝하지 않은 것
- 글로벌 파티션 인덱스와 마찬가지로 테이블 파티션 구성 변경 시 서비스 중단

**Prefixed vs Nonprefixed**

- Prefixed : 인덱스 파티션 키 컬럼이 인덱스 키 컬럼 왼쪽 선두에 위치
- Nonprefixed : 인덱스 파티션 키 컬럼이 인덱스 키 컬럼 왼쪽 선두에 위치 하지 않는다. 파티션 키가 인덱스 컬럼에 아예 속하지 않을 때도 여기에 속함

### 파티션을 활용한 대량 UPDATE 튜닝

- 입력/수정/삭제하는 데이터 비중이 5% 가 넘으면 인덱스를 활용하기 보다는 인덱스 없이 작업한 후 재성성하는게 더 빠름
- 예를 들어 10억건의 데이터가 있고 수정 비율이 5%가 넘으면, 데이터 수정시 인덱스를 Drop 하고 재성성하기 부담이 되 인덱스 를 그대로 두고 작업하는 경우가 많음 - 인덱스 전체 재생성의 부담성
- 테이블이 파티셔닝 되있고, 인덱스가 로컬 파티션인 경우 수정된 값을 갖는 임시 세그먼트를 만들어 원본 파티션과 바꿔치기하는 방식
1. 임시 테이블 생성
2. 데이터를 읽어 임시 테이블에 입력하면서 데이터 수정
3. 임시 테이블에 원본 테이블과 같은 구조로 인덱스 생성
    1. 파티션과 임시 테이블 수정
4. 임시 테이블 drop

### 파티션을 활용한 대량 DELETE 튜닝

- 대량 데이터를 지울 때는 남길 데이터만 백업했다가 재입력하는 방식이 빠름
    1. 임시 테이블 생성, 남길 데이터만 복제
    2. 삭제 대상 테이블 파티션 Truncate
    3. 임시 테이블에 복제해둔 데이터를 원본 테이블에 입력
    4. 임시 테이블 drop
- 서비스 중단없이 파티션을 Drop 또는 Truncate 하기위한 조건

    1. 파티션키와 커팅 기준 컬럼이 일치

    2. 파티션 단위와 커팅 주기가 일치

    3. 모든 인덱스가 로컬 파티션 인덱스


### 파티션을 활용한 대량 INSERT 튜닝

- 대량 데이터를 INSERT 하는 경우 인덱스를 Unusable 시켰다가 재성성하는 방식이 더 빠를 수 있음
    1. 인덱스 Unusable 상태로 전환
    2. (가능하면 Direct Path Insert) 대량 데이터 입력
    3. 인덱스 재생성

## Lock과 트랜잭션 동시성 제어

### 오라클 Lock

**오라클 Lock**

- 오라클은 공유리소스와 사용자 데이터 보호목적 다음과 같은 Lock을 사용
    - DML Lock
    - DDL Lock
    - 래치
    - 버퍼Lock
    - 라이브러리 캐시 Lock/Pin
- 래치는 SGA에 공유된 각종 자료구조를 보호하기 위해 사용
- 버퍼Lock은 버퍼블록에 대한 액세스를 직렬화 하기 위해 사용
- 라이브러리캐시 Lock과 Pin은 라이브러리캐시에 공유된 SQL커서와 PL/SQL프로그램을 보호하기 위해 사용
- 애플리케이션 개발측면에서 가장 중요하게 다루어야할 Lock은 DML Lock, DML Lock은 다중 트랜잭션이 동시에 액세스하는 데이터의 무결성을 보호
- DML Lock에는 테이블 Lock과 로우 Lock이 있음

**DML 로우 Lock**

- 두개의 동시 트랜잭션이 같은 로우를 변경하는 것을 방지
- 하나의 로우를 변경하려면 로우 Lock을 먼저 설정
- 어떤 DBMS든지 DML로우 Lock에는 배타적 모드를 사용하므로 수정을 진행중인(아직 커밋 전인) 로우를 다른 트랜잭션이 UPDATE하거나 DELETE할 수 없음
- MVCC모델을 사용하는 오라클은(for update절이 없는) SELECT문에 로우 Lock을 사용하지 않음
    - 오라클은 다른 트랜잭션이 변경한 로우를 읽을 때 복사본 블록을 만들어서 쿼리가 '시작된 시점'으로 되돌려서 읽음
    - 변경이 진행 중인(아직 커밋하지 않은)로우를 읽을 때도 Lock이 풀릴 때까지 기다리지 않고 복사본을 만들어서 읽음
    - 따라서 SELECT문에 Lock을 사용할 필요가 없다.
    - 결국, 오라클에서는 DML과 SELECT는 서로 진행을 방해하지 않음
    - DML끼리는 방해할 수 있는데 이는 어떤 DBMS도 마찬가지

**DML테이블 Lock**

- 오라클은 DML로우 Lock 설정하기 전 테이블 Lock을 먼저 설정
- 현재 트랜잭션이 갱신 중인 테이블 구조를 다른 트랜잭션이 변경하지 못하게 막기 위함
- TM Lock이라고도 부름
- 로우 Lock에는 항상 배타적 모드를 사용하지만, 테이블 Lock에는 여러가지 Lock모드 사용
- 테이블 Lock이 테이블전체에 Lock을 뜻하지는 않음
- 오라클의 테이블 Lock은 자신(테이블Lock을 설정한 트랜잭션)이 해당 테이블에서 현재 어떤 작업을 수행 중인지를 알리는 일종의 푯말(Flag)
- 테이블 Lock에는 여러 모드가 있고, 모드 선택에 따라 후행 트랜잭션이 수행 가능한 작업 범위가 결정
- Lock을얻고자하는 리소스가 사용중일 때 사용자가 선택할 수있는 3가지 경우(SELECT FOR UPDATE)
    1. Lock이 해제될 때까지 (select * from t for update)
    2. 일정시간만 기다리다 포기(select * from t for update wait 3)
    3. 기다리지 않고 작업을 포기 (select * from t for update nowait)

### 트랜잭션 동시성 제어

**비관적 동시성 제어**

- 비관적 동시성 제어는 자칫 시스템 동시성을 심각하게 떨어트릴 우려가 있지만, FOR UPDATE에 WAIT또는 NOWAIT옵션을 함께 사용한다면 LOCK을 얻기 위해 무한정 기다리지 않아도 됨
- WAIT나 NOWAIT 옵션 사용시 다른 트랜잭션에 의해 LOCK이 걸렸을 때 EXCEPTION을 만나므로 "다른 사용자에 의해 변경 중이니 다시 시도하십시오" 등의 메시지 출력하면서 트랜잭션 종료 가능
- 큐에 쌓은 데이터를 처리할 때 Lock이 걸린 레코드는 생략하고 다음 레코드를 계속 읽도록 구현하는 법(SQL에 ROWNUM 조건이 없으니 클라이언트단에서 100개 읽으면 멈추도록 구현해야 함)

**낙관적 동시성 제어**

- select 문에 읽은 컬럼이 매우 많다면 UPDATE문에 조건을 일일기 기술하는 것은 귀찮은 일
- 만약 UPDATE 대상 테이블에 최종 변경 일시를 관리하는 컬럼이 있다면, 이를 조건절에 넣어 간단히 해당 레코드의 갱신여부 판단 가능
- 낙관적 동시성 제어에서도 UPDATE전에 nowait 옵션을 활용한 SELECT 문을 한번더 수행함으로써 Lock에대한 예외처리를 한다면, 다른 트랜잭션이 설정한 Lock을 기다리지않게 구현할 수 있음

### 채번 방식에 따른 INSERT 성능 비교

**채번 테이블**

- 각 테이블 식별자의 단일 컬럼 일련 번호 또는 구분 속성별 순번 채번을 위해 별도 테이블을 관리하는 방식
- 채번 레코드를 읽어 1을 더한값으로 변경하고, 그 값을 새로운 레코드를 입력하는 데 사용
- 이방식은 채번 레코드 변경 과정에서 자연스럽게 액세스 직렬화(트랜잭션 줄세우기)가 이루어지므로 두 트랜잭션이 중복값을 채번할 가능성을 원천적으로 방지
- 장점
    - 범용성이 좋다
    - INSERT 과정에 중복 레코드 발생에 대비한 예외 처리에 크게 신경쓰지 않아도 되므로, 채번 함수만 잘 정의하면 편리하게 사용 가능
    - INSERT 과정에 결번 방지
    - PK가 복합컬럼일 때도 사용 가능
- 단점
    - 다른 채번 방식에 비해 성능이 안 좋다
    - 채번 레코드 변경하기 위한 로우 Lock 경합 때문
    - 로우 Lock은 기본적으로 대상 테이블에 Insert를 마치고 커밋 또는 롤백할 때까지 지속
    - 동시 INSERT가 아주 많으면 채번 레코드뿐아니라 채번 테이블 블록 자체에도 경합이 발생
    - 서로 다른 레코드를 변경하는 프로세스끼리도 경합할 수 있다는 뜻
    - 동시 INSERT가 아주 많은 테이블은 사실상 사용이 어려움

**시퀀스 오브젝트**

- 장점
    - 성능이 빠르다(성능 이슈가 없는 것은 아니다 - 시퀀스 채번과 정발생하는 LOCK)
    - 채번 테이블과 마찬가지로 INSERT 과정 중복레코드 발생에 대비한 예외처리 신경 안 써도 됨
- 시퀀스 오브젝트는 오라클 내부에서 관리하는 채번 테이블 (SYS.SEQ$테이블)DBA_SEQUENCES 뷰를 통해 조회 가능
- 시퀀스 오브젝트도 결국 테이블이므로 값을 읽고 변경하는 과정에 Lock매커니즘이 작동
- 캐시 사이즈를 적절히 설정하면 가장 빠른 성능을 제공
- 자율 트랜잭션 기능도 기본적으로 구현
- 자율 트랜잭션
    - pragma autonomous_transaction 으로 선언
    - 자율 트랜잭션 선언 시 내부에서 커밋 수행해도 메인 트랜잭션은 커밋하지 않은 상태로 남음
    - 메인 트랜잭션 insert문에서 채번 함수를 호출하고 최종적으로 커밋 전까지 다른 작업을 많이 수행하더라도 채번 테이블 로우Lock은 이미 해제한 상태여서 다른 트랜잭션을 블록킹하지 않음
- 단점
    - '기본적으로' pk가 단일 컬럼일 때만 사용 가능 (최소성 요건 만족 위해, 복합컬럼일 때도 할 수는 있음)
    - 신규 데이터 입력 과정에서 결번 발생 가능 (롤백, CACHE 옵션을 설정한 시퀀스가 캐시에서 밀려나는 경우)
    - 자주 사용하지 않아 캐시에서 밀려나거나 인스턴스를 재기동하는 순간, 캐시돼있던 번호는 모두 사라지며 디스크에서 다시 읽을 때 그다음 번호부터 읽음